"use strict";import{BufferAttribute as d,BufferGeometry as b,Mesh as D}from"three";export const Mesh_CUSTOM_ID="GetMesh_CustomID";export function getMeshByExpressID(n,o,y){const a=[],p=[],c=[],e=new Map,t=n.ifcManager.createSubset({ids:[y],modelID:o,removePrevious:!0,customID:Mesh_CUSTOM_ID}),u=t.geometry.attributes.position,x=t.geometry.attributes.expressID,m=t.geometry.groups.filter(r=>r.count!==0),I=[],f=t.material;let g=0;m.forEach(r=>{I.push(f[r.materialIndex]),r.materialIndex=g++});let l=0;if(!t.geometry.index)return;for(let r=0;r<t.geometry.index.count;r++){const s=t.geometry.index.array[r];e.has(s)||(a.push(u.array[3*s]),a.push(u.array[3*s+1]),a.push(u.array[3*s+2]),p.push(x.getX(s)),e.set(s,l++));const h=e.get(s);c.push(h)}const i=new b,M=new d(Float32Array.from(a),3),w=new d(Uint32Array.from(p),1);return i.setAttribute("position",M),i.setAttribute("expressID",w),i.setIndex(c),i.groups=m,i.computeVertexNormals(),n.ifcManager.removeSubset(o,void 0,Mesh_CUSTOM_ID),new D(i,I)}export async function createPropertyIndexes(n,o,y,a){const p=new Map,c=(await Promise.all(y.map(async e=>await n.ifcManager.getAllItemsOfType(o,e,!1)))).flat();for(const e of c){const t=await n.ifcManager.getPropertySets(o,e);for(const u of t){const x=await a(u);x&&p.set(x,{expressID:e,mesh:getMeshByExpressID(n,o,e)})}}return p}
